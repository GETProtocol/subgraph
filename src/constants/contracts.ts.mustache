// WARNING: src/constants/contracts.ts is autogenerated from the contracts.ts.mustache file.
// Do not edit contracts.ts directly as your changes will be overwritten.

import { Address, BigInt } from "@graphprotocol/graph-ts";

export let CHAIN_NAME = "{{ chainName }}".toUpperCase();
export let CURRENCY_CONVERSION_ACTIVATED_BLOCK = BigInt.fromI32(20410204);
export let GUTS_ON_CREDIT_BLOCK = BigInt.fromI32(39300544);
export let FUEL_BRIDGE_RECEIVER = Address.fromString("{{ addresses.FuelBridgeReceiver }}");
export let STAKING = Address.fromString("{{ addresses.Staking }}");
export let GET_SAAS = Address.fromString("{{ addresses.GETSaaS }}")
export let EVENT_METADATA_STORAGE_ADDRESS_V1 = {{ ^v1.EventMetadataStorage.address }}Address.zero(){{ /v1.EventMetadataStorage.address }}{{ #v1.EventMetadataStorage.address }}Address.fromString("{{ v1.EventMetadataStorage.address }}"){{ /v1.EventMetadataStorage.address }};
export let EVENT_METADATA_STORAGE_ADDRESS_V1_1 = {{ ^v1_1.EventMetadataStorage.address }}Address.zero(){{ /v1_1.EventMetadataStorage.address }}{{ #v1_1.EventMetadataStorage.address }}Address.fromString("{{ v1_1.EventMetadataStorage.address }}"){{ /v1_1.EventMetadataStorage.address }};
export let BASEGET_ADDRESS_V1_1 = {{ ^v1_1.BaseGET.address }}Address.zero(){{ /v1_1.BaseGET.address }}{{ #v1_1.BaseGET.address }}Address.fromString("{{ v1_1.BaseGET.address }}"){{ /v1_1.BaseGET.address }};
export let ECONOMICS_ADDRESS_V1_1 = {{ ^v1_1.EconomicsGET.address }}Address.zero(){{ /v1_1.EconomicsGET.address }}{{ #v1_1.EconomicsGET.address }}Address.fromString("{{ v1_1.EconomicsGET.address }}"){{ /v1_1.EconomicsGET.address }};

// The block in which the on-chain economics was switched on.
// See: https://polygonscan.com/tx/0xe9ef44375aa2a2cb70fb6244e60ca6c8ca60fca3dd6e0fa3b42e779d1d0faba3
export let FUEL_ACTIVATED_BLOCK = BigInt.fromI32({{ v1_1.fuelActivatedBlock }}{{ ^v1_1.fuelActivatedBlock }}0{{ /v1_1.fuelActivatedBlock }});

// After V1.1 we enforced separate relayers per-ticketeer and started assigning a string of "name" alongside the
// relayer data. This maps the provided relayerAddress to the *accounting* integrator that was used by its index.
// This mapping allows us to fetch the integrator record that was used for accounting purposes for a tx.
export let RELAYER_MAPPING = new Map<string, string>();
{{ #relayers }}
RELAYER_MAPPING.set("{{ 0 }}", "{{ 1 }}"); // "{{ 2 }}"
{{ /relayers }}

// We also created individual integrators for each previous ticketeer. To make the mints from V1 and V1.1 be forwards
// compatible with the future integrator data we must map the ticketeerName of the event to the integratorIndex.
//
// Conmbined with the above mapping this means:
//   - The integrator will be billed using their RELAYER_MAPPING
//   - The integrator record will be associated using their TICKETEER_MAPPING
export let TICKETEER_MAPPING = new Map<string, string>();
{{ #ticketeers }}
TICKETEER_MAPPING.set("{{ 0 }}", "{{ 1 }}");
{{ /ticketeers }}