// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { ethereum, JSONValue, TypedMap, Entity, Bytes, Address, BigInt } from "@graphprotocol/graph-ts";

export class ConfigurationChanged extends ethereum.Event {
  get params(): ConfigurationChanged__Params {
    return new ConfigurationChanged__Params(this);
  }
}

export class ConfigurationChanged__Params {
  _event: ConfigurationChanged;

  constructor(event: ConfigurationChanged) {
    this._event = event;
  }

  get addressBouncer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get addressMetadata(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get addressFinance(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get addressERC721(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class ConfigurationChangedEcon extends ethereum.Event {
  get params(): ConfigurationChangedEcon__Params {
    return new ConfigurationChangedEcon__Params(this);
  }
}

export class ConfigurationChangedEcon__Params {
  _event: ConfigurationChangedEcon;

  constructor(event: ConfigurationChangedEcon) {
    this._event = event;
  }

  get AddressEconomics(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get DepotAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class NFTCheckedIn extends ethereum.Event {
  get params(): NFTCheckedIn__Params {
    return new NFTCheckedIn__Params(this);
  }
}

export class NFTCheckedIn__Params {
  _event: NFTCheckedIn;

  constructor(event: NFTCheckedIn) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class illegalScan extends ethereum.Event {
  get params(): illegalScan__Params {
    return new illegalScan__Params(this);
  }
}

export class illegalScan__Params {
  _event: illegalScan;

  constructor(event: illegalScan) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class nftClaimed extends ethereum.Event {
  get params(): nftClaimed__Params {
    return new nftClaimed__Params(this);
  }
}

export class nftClaimed__Params {
  _event: nftClaimed;

  constructor(event: nftClaimed) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get externalAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class nftMinted extends ethereum.Event {
  get params(): nftMinted__Params {
    return new nftMinted__Params(this);
  }
}

export class nftMinted__Params {
  _event: nftMinted;

  constructor(event: nftMinted) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get destinationAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class nftTokenURIEdited extends ethereum.Event {
  get params(): nftTokenURIEdited__Params {
    return new nftTokenURIEdited__Params(this);
  }
}

export class nftTokenURIEdited__Params {
  _event: nftTokenURIEdited;

  constructor(event: nftTokenURIEdited) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get netTokenURI(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class primarySaleMint extends ethereum.Event {
  get params(): primarySaleMint__Params {
    return new primarySaleMint__Params(this);
  }
}

export class primarySaleMint__Params {
  _event: primarySaleMint;

  constructor(event: primarySaleMint) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get destinationAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get eventAddress(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get primaryPrice(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class saleCollaterizedIntentory extends ethereum.Event {
  get params(): saleCollaterizedIntentory__Params {
    return new saleCollaterizedIntentory__Params(this);
  }
}

export class saleCollaterizedIntentory__Params {
  _event: saleCollaterizedIntentory;

  constructor(event: saleCollaterizedIntentory) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get eventAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class secondarySale extends ethereum.Event {
  get params(): secondarySale__Params {
    return new secondarySale__Params(this);
  }
}

export class secondarySale__Params {
  _event: secondarySale;

  constructor(event: secondarySale) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get destinationAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get eventAddress(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get secondaryPrice(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class ticketInvalidated extends ethereum.Event {
  get params(): ticketInvalidated__Params {
    return new ticketInvalidated__Params(this);
  }
}

export class ticketInvalidated__Params {
  _event: ticketInvalidated;

  constructor(event: ticketInvalidated) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get originAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class ticketScanned extends ethereum.Event {
  get params(): ticketScanned__Params {
    return new ticketScanned__Params(this);
  }
}

export class ticketScanned__Params {
  _event: ticketScanned;

  constructor(event: ticketScanned) {
    this._event = event;
  }

  get nftIndex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get getUsed(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NFT__returnStructTicketResultValue0Struct extends ethereum.Tuple {
  get event_address(): Address {
    return this[0].toAddress();
  }

  get ticket_metadata(): Array<Bytes> {
    return this[1].toBytesArray();
  }

  get prices_sold(): Array<BigInt> {
    return this[2].toBigIntArray();
  }

  get set_aside(): boolean {
    return this[3].toBoolean();
  }

  get scanned(): boolean {
    return this[4].toBoolean();
  }

  get valid(): boolean {
    return this[5].toBoolean();
  }
}

export class NFT__ticketMetadataAddressResult {
  value0: Address;
  value1: Array<Bytes>;
  value2: Array<BigInt>;
  value3: boolean;
  value4: boolean;
  value5: boolean;

  constructor(
    value0: Address,
    value1: Array<Bytes>,
    value2: Array<BigInt>,
    value3: boolean,
    value4: boolean,
    value5: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytesArray(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigIntArray(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    map.set("value5", ethereum.Value.fromBoolean(this.value5));
    return map;
  }
}

export class NFT__ticketMetadataIndexResult {
  value0: Address;
  value1: Array<Bytes>;
  value2: Array<BigInt>;
  value3: boolean;
  value4: boolean;
  value5: boolean;

  constructor(
    value0: Address,
    value1: Array<Bytes>,
    value2: Array<BigInt>,
    value3: boolean,
    value4: boolean,
    value5: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytesArray(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigIntArray(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    map.set("value5", ethereum.Value.fromBoolean(this.value5));
    return map;
  }
}

export class NFT extends ethereum.SmartContract {
  static bind(address: Address): NFT {
    return new NFT("NFT", address);
  }

  _mintGETNFT(
    destinationAddress: Address,
    eventAddress: Address,
    issuePrice: BigInt,
    ticketURI: string,
    ticketMetadata: Array<Bytes>,
    setAsideNFT: boolean
  ): BigInt {
    let result = super.call("_mintGETNFT", "_mintGETNFT(address,address,uint256,string,bytes32[],bool):(uint256)", [
      ethereum.Value.fromAddress(destinationAddress),
      ethereum.Value.fromAddress(eventAddress),
      ethereum.Value.fromUnsignedBigInt(issuePrice),
      ethereum.Value.fromString(ticketURI),
      ethereum.Value.fromFixedBytesArray(ticketMetadata),
      ethereum.Value.fromBoolean(setAsideNFT),
    ]);

    return result[0].toBigInt();
  }

  try__mintGETNFT(
    destinationAddress: Address,
    eventAddress: Address,
    issuePrice: BigInt,
    ticketURI: string,
    ticketMetadata: Array<Bytes>,
    setAsideNFT: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_mintGETNFT", "_mintGETNFT(address,address,uint256,string,bytes32[],bool):(uint256)", [
      ethereum.Value.fromAddress(destinationAddress),
      ethereum.Value.fromAddress(eventAddress),
      ethereum.Value.fromUnsignedBigInt(issuePrice),
      ethereum.Value.fromString(ticketURI),
      ethereum.Value.fromFixedBytesArray(ticketMetadata),
      ethereum.Value.fromBoolean(setAsideNFT),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  addressToIndex(ownerAddress: Address): BigInt {
    let result = super.call("addressToIndex", "addressToIndex(address):(uint256)", [
      ethereum.Value.fromAddress(ownerAddress),
    ]);

    return result[0].toBigInt();
  }

  try_addressToIndex(ownerAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("addressToIndex", "addressToIndex(address):(uint256)", [
      ethereum.Value.fromAddress(ownerAddress),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  contractName(): string {
    let result = super.call("contractName", "contractName():(string)", []);

    return result[0].toString();
  }

  try_contractName(): ethereum.CallResult<string> {
    let result = super.tryCall("contractName", "contractName():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  contractVersion(): string {
    let result = super.call("contractVersion", "contractVersion():(string)", []);

    return result[0].toString();
  }

  try_contractVersion(): ethereum.CallResult<string> {
    let result = super.tryCall("contractVersion", "contractVersion():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  isNFTClaimable(nftIndex: BigInt, ownerAddress: Address): boolean {
    let result = super.call("isNFTClaimable", "isNFTClaimable(uint256,address):(bool)", [
      ethereum.Value.fromUnsignedBigInt(nftIndex),
      ethereum.Value.fromAddress(ownerAddress),
    ]);

    return result[0].toBoolean();
  }

  try_isNFTClaimable(nftIndex: BigInt, ownerAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isNFTClaimable", "isNFTClaimable(uint256,address):(bool)", [
      ethereum.Value.fromUnsignedBigInt(nftIndex),
      ethereum.Value.fromAddress(ownerAddress),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isNFTSellable(nftIndex: BigInt, ownerAddress: Address): boolean {
    let result = super.call("isNFTSellable", "isNFTSellable(uint256,address):(bool)", [
      ethereum.Value.fromUnsignedBigInt(nftIndex),
      ethereum.Value.fromAddress(ownerAddress),
    ]);

    return result[0].toBoolean();
  }

  try_isNFTSellable(nftIndex: BigInt, ownerAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isNFTSellable", "isNFTSellable(uint256,address):(bool)", [
      ethereum.Value.fromUnsignedBigInt(nftIndex),
      ethereum.Value.fromAddress(ownerAddress),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  primarySale(
    destinationAddress: Address,
    eventAddress: Address,
    primaryPrice: BigInt,
    basePrice: BigInt,
    orderTime: BigInt,
    ticketURI: string,
    ticketMetadata: Array<Bytes>
  ): BigInt {
    let result = super.call(
      "primarySale",
      "primarySale(address,address,uint256,uint256,uint256,string,bytes32[]):(uint256)",
      [
        ethereum.Value.fromAddress(destinationAddress),
        ethereum.Value.fromAddress(eventAddress),
        ethereum.Value.fromUnsignedBigInt(primaryPrice),
        ethereum.Value.fromUnsignedBigInt(basePrice),
        ethereum.Value.fromUnsignedBigInt(orderTime),
        ethereum.Value.fromString(ticketURI),
        ethereum.Value.fromFixedBytesArray(ticketMetadata),
      ]
    );

    return result[0].toBigInt();
  }

  try_primarySale(
    destinationAddress: Address,
    eventAddress: Address,
    primaryPrice: BigInt,
    basePrice: BigInt,
    orderTime: BigInt,
    ticketURI: string,
    ticketMetadata: Array<Bytes>
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "primarySale",
      "primarySale(address,address,uint256,uint256,uint256,string,bytes32[]):(uint256)",
      [
        ethereum.Value.fromAddress(destinationAddress),
        ethereum.Value.fromAddress(eventAddress),
        ethereum.Value.fromUnsignedBigInt(primaryPrice),
        ethereum.Value.fromUnsignedBigInt(basePrice),
        ethereum.Value.fromUnsignedBigInt(orderTime),
        ethereum.Value.fromString(ticketURI),
        ethereum.Value.fromFixedBytesArray(ticketMetadata),
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  returnStructTicket(nftIndex: BigInt): NFT__returnStructTicketResultValue0Struct {
    let result = super.call(
      "returnStructTicket",
      "returnStructTicket(uint256):((address,bytes32[],uint256[],bool,bool,bool))",
      [ethereum.Value.fromUnsignedBigInt(nftIndex)]
    );

    return result[0].toTuple() as NFT__returnStructTicketResultValue0Struct;
  }

  try_returnStructTicket(nftIndex: BigInt): ethereum.CallResult<NFT__returnStructTicketResultValue0Struct> {
    let result = super.tryCall(
      "returnStructTicket",
      "returnStructTicket(uint256):((address,bytes32[],uint256[],bool,bool,bool))",
      [ethereum.Value.fromUnsignedBigInt(nftIndex)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toTuple() as NFT__returnStructTicketResultValue0Struct);
  }

  secondaryTransfer(
    originAddress: Address,
    destinationAddress: Address,
    orderTime: BigInt,
    secondaryPrice: BigInt
  ): BigInt {
    let result = super.call("secondaryTransfer", "secondaryTransfer(address,address,uint256,uint256):(uint256)", [
      ethereum.Value.fromAddress(originAddress),
      ethereum.Value.fromAddress(destinationAddress),
      ethereum.Value.fromUnsignedBigInt(orderTime),
      ethereum.Value.fromUnsignedBigInt(secondaryPrice),
    ]);

    return result[0].toBigInt();
  }

  try_secondaryTransfer(
    originAddress: Address,
    destinationAddress: Address,
    orderTime: BigInt,
    secondaryPrice: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall("secondaryTransfer", "secondaryTransfer(address,address,uint256,uint256):(uint256)", [
      ethereum.Value.fromAddress(originAddress),
      ethereum.Value.fromAddress(destinationAddress),
      ethereum.Value.fromUnsignedBigInt(orderTime),
      ethereum.Value.fromUnsignedBigInt(secondaryPrice),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ticketMetadataAddress(ownerAddress: Address): NFT__ticketMetadataAddressResult {
    let result = super.call(
      "ticketMetadataAddress",
      "ticketMetadataAddress(address):(address,bytes32[],uint256[],bool,bool,bool)",
      [ethereum.Value.fromAddress(ownerAddress)]
    );

    return new NFT__ticketMetadataAddressResult(
      result[0].toAddress(),
      result[1].toBytesArray(),
      result[2].toBigIntArray(),
      result[3].toBoolean(),
      result[4].toBoolean(),
      result[5].toBoolean()
    );
  }

  try_ticketMetadataAddress(ownerAddress: Address): ethereum.CallResult<NFT__ticketMetadataAddressResult> {
    let result = super.tryCall(
      "ticketMetadataAddress",
      "ticketMetadataAddress(address):(address,bytes32[],uint256[],bool,bool,bool)",
      [ethereum.Value.fromAddress(ownerAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new NFT__ticketMetadataAddressResult(
        value[0].toAddress(),
        value[1].toBytesArray(),
        value[2].toBigIntArray(),
        value[3].toBoolean(),
        value[4].toBoolean(),
        value[5].toBoolean()
      )
    );
  }

  ticketMetadataIndex(nftIndex: BigInt): NFT__ticketMetadataIndexResult {
    let result = super.call(
      "ticketMetadataIndex",
      "ticketMetadataIndex(uint256):(address,bytes32[],uint256[],bool,bool,bool)",
      [ethereum.Value.fromUnsignedBigInt(nftIndex)]
    );

    return new NFT__ticketMetadataIndexResult(
      result[0].toAddress(),
      result[1].toBytesArray(),
      result[2].toBigIntArray(),
      result[3].toBoolean(),
      result[4].toBoolean(),
      result[5].toBoolean()
    );
  }

  try_ticketMetadataIndex(nftIndex: BigInt): ethereum.CallResult<NFT__ticketMetadataIndexResult> {
    let result = super.tryCall(
      "ticketMetadataIndex",
      "ticketMetadataIndex(uint256):(address,bytes32[],uint256[],bool,bool,bool)",
      [ethereum.Value.fromUnsignedBigInt(nftIndex)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new NFT__ticketMetadataIndexResult(
        value[0].toAddress(),
        value[1].toBytesArray(),
        value[2].toBigIntArray(),
        value[3].toBoolean(),
        value[4].toBoolean(),
        value[5].toBoolean()
      )
    );
  }
}

export class _initialize_baseCall extends ethereum.Call {
  get inputs(): _initialize_baseCall__Inputs {
    return new _initialize_baseCall__Inputs(this);
  }

  get outputs(): _initialize_baseCall__Outputs {
    return new _initialize_baseCall__Outputs(this);
  }
}

export class _initialize_baseCall__Inputs {
  _call: _initialize_baseCall;

  constructor(call: _initialize_baseCall) {
    this._call = call;
  }

  get address_bouncer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get address_metadata(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get address_finance(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get address_erc721(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get address_economics(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get address_fueldepot(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class _initialize_baseCall__Outputs {
  _call: _initialize_baseCall;

  constructor(call: _initialize_baseCall) {
    this._call = call;
  }
}

export class _mintGETNFTCall extends ethereum.Call {
  get inputs(): _mintGETNFTCall__Inputs {
    return new _mintGETNFTCall__Inputs(this);
  }

  get outputs(): _mintGETNFTCall__Outputs {
    return new _mintGETNFTCall__Outputs(this);
  }
}

export class _mintGETNFTCall__Inputs {
  _call: _mintGETNFTCall;

  constructor(call: _mintGETNFTCall) {
    this._call = call;
  }

  get destinationAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eventAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get issuePrice(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get ticketURI(): string {
    return this._call.inputValues[3].value.toString();
  }

  get ticketMetadata(): Array<Bytes> {
    return this._call.inputValues[4].value.toBytesArray();
  }

  get setAsideNFT(): boolean {
    return this._call.inputValues[5].value.toBoolean();
  }
}

export class _mintGETNFTCall__Outputs {
  _call: _mintGETNFTCall;

  constructor(call: _mintGETNFTCall) {
    this._call = call;
  }

  get nftIndexM(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ChangeConfigurationCall extends ethereum.Call {
  get inputs(): ChangeConfigurationCall__Inputs {
    return new ChangeConfigurationCall__Inputs(this);
  }

  get outputs(): ChangeConfigurationCall__Outputs {
    return new ChangeConfigurationCall__Outputs(this);
  }
}

export class ChangeConfigurationCall__Inputs {
  _call: ChangeConfigurationCall;

  constructor(call: ChangeConfigurationCall) {
    this._call = call;
  }

  get newAddressBouncer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newAddressMetadata(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get newAddressFinance(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get newAddressERC721(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class ChangeConfigurationCall__Outputs {
  _call: ChangeConfigurationCall;

  constructor(call: ChangeConfigurationCall) {
    this._call = call;
  }
}

export class ChangeConfigurationEconCall extends ethereum.Call {
  get inputs(): ChangeConfigurationEconCall__Inputs {
    return new ChangeConfigurationEconCall__Inputs(this);
  }

  get outputs(): ChangeConfigurationEconCall__Outputs {
    return new ChangeConfigurationEconCall__Outputs(this);
  }
}

export class ChangeConfigurationEconCall__Inputs {
  _call: ChangeConfigurationEconCall;

  constructor(call: ChangeConfigurationEconCall) {
    this._call = call;
  }

  get newAddressEconomics(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newDepotAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ChangeConfigurationEconCall__Outputs {
  _call: ChangeConfigurationEconCall;

  constructor(call: ChangeConfigurationEconCall) {
    this._call = call;
  }
}

export class CheckInCall extends ethereum.Call {
  get inputs(): CheckInCall__Inputs {
    return new CheckInCall__Inputs(this);
  }

  get outputs(): CheckInCall__Outputs {
    return new CheckInCall__Outputs(this);
  }
}

export class CheckInCall__Inputs {
  _call: CheckInCall;

  constructor(call: CheckInCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class CheckInCall__Outputs {
  _call: CheckInCall;

  constructor(call: CheckInCall) {
    this._call = call;
  }
}

export class ClaimgetNFTCall extends ethereum.Call {
  get inputs(): ClaimgetNFTCall__Inputs {
    return new ClaimgetNFTCall__Inputs(this);
  }

  get outputs(): ClaimgetNFTCall__Outputs {
    return new ClaimgetNFTCall__Outputs(this);
  }
}

export class ClaimgetNFTCall__Inputs {
  _call: ClaimgetNFTCall;

  constructor(call: ClaimgetNFTCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get externalAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ClaimgetNFTCall__Outputs {
  _call: ClaimgetNFTCall;

  constructor(call: ClaimgetNFTCall) {
    this._call = call;
  }
}

export class EditTokenURIbyAddressCall extends ethereum.Call {
  get inputs(): EditTokenURIbyAddressCall__Inputs {
    return new EditTokenURIbyAddressCall__Inputs(this);
  }

  get outputs(): EditTokenURIbyAddressCall__Outputs {
    return new EditTokenURIbyAddressCall__Outputs(this);
  }
}

export class EditTokenURIbyAddressCall__Inputs {
  _call: EditTokenURIbyAddressCall;

  constructor(call: EditTokenURIbyAddressCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newTokenURI(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class EditTokenURIbyAddressCall__Outputs {
  _call: EditTokenURIbyAddressCall;

  constructor(call: EditTokenURIbyAddressCall) {
    this._call = call;
  }
}

export class EditTokenURIbyIndexCall extends ethereum.Call {
  get inputs(): EditTokenURIbyIndexCall__Inputs {
    return new EditTokenURIbyIndexCall__Inputs(this);
  }

  get outputs(): EditTokenURIbyIndexCall__Outputs {
    return new EditTokenURIbyIndexCall__Outputs(this);
  }
}

export class EditTokenURIbyIndexCall__Inputs {
  _call: EditTokenURIbyIndexCall;

  constructor(call: EditTokenURIbyIndexCall) {
    this._call = call;
  }

  get nftIndex(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get newTokenURI(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class EditTokenURIbyIndexCall__Outputs {
  _call: EditTokenURIbyIndexCall;

  constructor(call: EditTokenURIbyIndexCall) {
    this._call = call;
  }
}

export class InvalidateAddressNFTCall extends ethereum.Call {
  get inputs(): InvalidateAddressNFTCall__Inputs {
    return new InvalidateAddressNFTCall__Inputs(this);
  }

  get outputs(): InvalidateAddressNFTCall__Outputs {
    return new InvalidateAddressNFTCall__Outputs(this);
  }
}

export class InvalidateAddressNFTCall__Inputs {
  _call: InvalidateAddressNFTCall;

  constructor(call: InvalidateAddressNFTCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class InvalidateAddressNFTCall__Outputs {
  _call: InvalidateAddressNFTCall;

  constructor(call: InvalidateAddressNFTCall) {
    this._call = call;
  }
}

export class PrimarySaleCall extends ethereum.Call {
  get inputs(): PrimarySaleCall__Inputs {
    return new PrimarySaleCall__Inputs(this);
  }

  get outputs(): PrimarySaleCall__Outputs {
    return new PrimarySaleCall__Outputs(this);
  }
}

export class PrimarySaleCall__Inputs {
  _call: PrimarySaleCall;

  constructor(call: PrimarySaleCall) {
    this._call = call;
  }

  get destinationAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eventAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get primaryPrice(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get basePrice(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get ticketURI(): string {
    return this._call.inputValues[5].value.toString();
  }

  get ticketMetadata(): Array<Bytes> {
    return this._call.inputValues[6].value.toBytesArray();
  }
}

export class PrimarySaleCall__Outputs {
  _call: PrimarySaleCall;

  constructor(call: PrimarySaleCall) {
    this._call = call;
  }

  get nftIndexP(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ScanNFTCall extends ethereum.Call {
  get inputs(): ScanNFTCall__Inputs {
    return new ScanNFTCall__Inputs(this);
  }

  get outputs(): ScanNFTCall__Outputs {
    return new ScanNFTCall__Outputs(this);
  }
}

export class ScanNFTCall__Inputs {
  _call: ScanNFTCall;

  constructor(call: ScanNFTCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ScanNFTCall__Outputs {
  _call: ScanNFTCall;

  constructor(call: ScanNFTCall) {
    this._call = call;
  }
}

export class SecondaryTransferCall extends ethereum.Call {
  get inputs(): SecondaryTransferCall__Inputs {
    return new SecondaryTransferCall__Inputs(this);
  }

  get outputs(): SecondaryTransferCall__Outputs {
    return new SecondaryTransferCall__Outputs(this);
  }
}

export class SecondaryTransferCall__Inputs {
  _call: SecondaryTransferCall;

  constructor(call: SecondaryTransferCall) {
    this._call = call;
  }

  get originAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get destinationAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get orderTime(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get secondaryPrice(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class SecondaryTransferCall__Outputs {
  _call: SecondaryTransferCall;

  constructor(call: SecondaryTransferCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetBaseGETFeeCall extends ethereum.Call {
  get inputs(): SetBaseGETFeeCall__Inputs {
    return new SetBaseGETFeeCall__Inputs(this);
  }

  get outputs(): SetBaseGETFeeCall__Outputs {
    return new SetBaseGETFeeCall__Outputs(this);
  }
}

export class SetBaseGETFeeCall__Inputs {
  _call: SetBaseGETFeeCall;

  constructor(call: SetBaseGETFeeCall) {
    this._call = call;
  }

  get newBaseGETFee(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetBaseGETFeeCall__Outputs {
  _call: SetBaseGETFeeCall;

  constructor(call: SetBaseGETFeeCall) {
    this._call = call;
  }
}
